classdef ClassificationModel < handle
    properties(SetAccess = private)
        sm;
        num_features;
        class_options;
        A_islogical;
    end
    
    methods(Static)
        
        function [sm_out] = column_corr(A,y,w,k,tol)
            
            %remove rare events for speed
            sm_valid = sum(A~=0,1)>0;
            A = A(:,sm_valid);
            
            y = -1.*(y==0)+1.*(y>0);
            
            %make a sparse diagnal
            diagw = spdiags(w, 0, length(w), length(w));
            
            %take the weight into account;
            y = w.*y;
            A = diagw*A;
            
            %compute the column norms
            d = sqrt(sum(A.*A,1))';
            d(d==0)=1;
            
            %make sparse diagnal
            %d = spdiags(1./d, 0, size(A,2), size(A,2));
            
            c = (A.'*y)./(d.*norm(y));
            c = abs(c);
            
            sm_curr = find(c>=tol);
            
            if (length(sm_curr)>k)
                [~,I] = sort(c,'descend');
                sm_curr = I(1:k);
            end
            
            if isempty(sm_curr)
                error('Could not find any correlated columns.');
            end
            
            sm_out = false(1,size(A,2));

            sm_valid = find(sm_valid);
            sm_out(sm_valid(sm_curr)) = true;
        end
        
        function w = getDefaultWeights(y)
            
            good = sum(y==0);
            bad = sum(y>0);
            w = .98/good.*(y==0)+0.02/bad.*(y>0);
        end
        
        function w = getClassUniformWeights(y)
            
            good = sum(y==0);
            bad = sum(y>0);
            w = .5/good.*(y==0)+.5/bad.*(y>0);
        end
        
        function w = getUniformWeights(y)
            
            w = ones(length(y),1);
        end
        
        function [A,y,w,p] = subsample(A,y,w,options)
            
            if islogical(options.subsample) && ~options.subsample
                return
            end
            
            n = size(A,1);
            if (ischar(options.subsample) && strcmpi(options.subsample,'sqrt'))
                n = round(sqrt(size(A,1)));
            elseif (isfloat(options.subsample) && options.subsample>=0 && options.subsample<=1.0)
                n = round(options.subsample*size(A,1));
            elseif (isfloat(options.subsample) && options.subsample>=1.0)
                n = min(n,round(options.subsample));
            end
            
            if (n<size(A,1))
                n = max(100,n);
                
                %select the subset
                pc = randperm(size(A,1),n);
                p = false(size(A,1),1);
                p(pc) = true;
                
                A = A(p,:);
                y = y(p);
                w = w(p);
            else
                p = true(size(A,1),1);
            end
            
        end
        
        function z = invprob(p)
            z = log(p./(1-p));
        end
        
    end
    
    methods
        function obj = ClassificationModel(A,y,options)
            
            assert(size(A,1)>=1 && size(A,2)>=1, ['Invalid dimension of the feature matrix: ', num2str(size(A))]);
            assert(size(A,1)==length(y),'Feature matrix must have same number of rows as label vector.');
            assert(length(unique(y))==2,'Can only process two labels classification.');
            
            obj.A_islogical = islogical(A);
            obj.class_options = options;
            obj.num_features = size(A,2);
            
            if (~islogical(options.feature_select) && numel(options.feature_select)==1 && options.feature_select)
                
                %good = sum(y==0);
                %bad = sum(y>0);
                %w0 = .5/good.*(y==0)+.5/bad.*(y>0);
                
                w0 = ones(size(y));
                
                %cut down the number of features
                obj.sm = ClassificationModel.column_corr(A, y, w0, options.feature_select, 0.0);
            elseif (islogical(options.feature_select) && numel(options.feature_select)==1 && ~options.feature_select)
                obj.sm = [];
            else
                if islogical(options.feature_select)
                    assert(length(options.feature_select)==size(A,2), 'Column indicies must match size of matrix.');
                    obj.sm = options.feature_select;
                elseif isvector(options.feature_select)
                    assert(max(options.feature_select)<=size(A,2), 'Column indicies must match size of matrix.');
                    
                    idx = false(1,size(A,2));
                    idx(options.feature_select) = true;
                    
                    obj.sm = idx;
                else
                    error('Unknown feature selection vector type.');
                end
            end

            if (sum(obj.sm)<size(obj.sm,1))
                fprintf('Selected %d out of %d features for computation.\n', sum(obj.sm), size(obj.sm, 1));
            end
        end
        
        function z = margin(obj, A, cutoff)
            p = obj.predict(A);
            z = invprob(p);
            
            z(z<-cutoff) = cutoff;
            z(z>cutoff) = cutoff;
            
        end
        
        function y = predict(obj, A)
            
            assert(size(A,2)==obj.getNumFeatures(),'Feature matrix does not have same number of features as original training matrix.');
            assert(islogical(A)==obj.A_islogical,'Test A must be of same type as training A.');
            
            y = [];
        end
        
        function v = getNumFeatures(obj)
            v = obj.num_features;
        end
        
        function [X,Y,T,auc] = getROCPoints(obj, A, y, Xcrit, Ycrit)
            
            if (nargin<5)
                Xcrit = 'fpr';
                Ycrit = 'tpr';
            end
            
            y_pred = obj.predict(A);
            
            [X,Y,T,auc] = perfcurve(y>0,y_pred,true,'UseNearest','off','TVals',[0.0, logspace(-5,-2, 2000), linspace(0.01+10*eps,1.0+10*eps, 2000)], 'Xcrit',Xcrit, 'Ycrit',Ycrit);
        end
        
        function options = getOptions(obj)
            options = obj.class_options;
        end
        
        function value = getActiveFeatures(obj)
            if (isempty(obj.sm))
                value = 1:obj.getNumFeatures();
            else
                if (islogical(obj.sm))
                    value = find(obj.sm);
                else
                    value = obj.sm;
                end
            end
        end
        
        function [] = plotROC(obj,A,y)
            [X,Y,~,auc] = getROCPoints(obj, A, y);
            
            plot(X ,Y);
            xlim([0, .2]);
            ylim([0, 1.0]);
            xlabel('FPR');
            ylabel('TPR');
            title(['AUC=',num2str(auc)])
        end
        
        
    end % methods
    
    
end % classdef